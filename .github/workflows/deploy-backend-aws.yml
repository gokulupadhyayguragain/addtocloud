name: Deploy Backend to AWS

on:
  push:
    branches: [main]
    paths: ['apps/backend/**']
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: addtocloud-api
  ECS_SERVICE: addtocloud-api-service
  ECS_CLUSTER: addtocloud-cluster
  ECS_TASK_DEFINITION: addtocloud-api-task
  CONTAINER_NAME: addtocloud-api

jobs:
  deploy-aws:
    name: Deploy to AWS ECS
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./apps/backend

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}

    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2

    - name: Create ECR repository if it doesn't exist
      run: |
        aws ecr describe-repositories --repository-names $ECR_REPOSITORY 2>/dev/null || \
        aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION

    - name: Build, tag, and push image to Amazon ECR
      id: build-image
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        # Build Docker image
        docker build -f Dockerfile.production -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
        docker build -f Dockerfile.production -t $ECR_REGISTRY/$ECR_REPOSITORY:latest .
        
        # Push images to ECR
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
        docker push $ECR_REGISTRY/$ECR_REPOSITORY:latest
        
        echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT

    - name: Create ECS cluster if it doesn't exist
      run: |
        echo "Creating ECS cluster..."
        aws ecs describe-clusters --clusters $ECS_CLUSTER 2>/dev/null || \
        aws ecs create-cluster --cluster-name $ECS_CLUSTER
        
        echo "Waiting for cluster to be ready..."
        sleep 10

    - name: Create or update ECS task definition
      id: task-def
      env:
        ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
        IMAGE_TAG: ${{ github.sha }}
      run: |
        cat > task-definition.json << EOF
        {
          "family": "$ECS_TASK_DEFINITION",
          "networkMode": "awsvpc",
          "requiresCompatibilities": ["FARGATE"],
          "cpu": "256",
          "memory": "512",
          "executionRoleArn": "arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/ecsTaskExecutionRole",
          "containerDefinitions": [
            {
              "name": "$CONTAINER_NAME",
              "image": "$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG",
              "portMappings": [
                {
                  "containerPort": 8080,
                  "protocol": "tcp"
                }
              ],
              "essential": true,
              "environment": [
                {
                  "name": "PORT",
                  "value": "8080"
                },
                {
                  "name": "GIN_MODE",
                  "value": "release"
                }
              ],
              "logConfiguration": {
                "logDriver": "awslogs",
                "options": {
                  "awslogs-group": "/ecs/addtocloud-api",
                  "awslogs-region": "$AWS_REGION",
                  "awslogs-stream-prefix": "ecs"
                }
              }
            }
          ]
        }
        EOF
        
        # Create log group if it doesn't exist
        aws logs create-log-group --log-group-name /ecs/addtocloud-api 2>/dev/null || true
        
        # Register task definition
        aws ecs register-task-definition --cli-input-json file://task-definition.json

    - name: Create or update ECS service
      run: |
        # Check if service exists
        if aws ecs describe-services --cluster $ECS_CLUSTER --services $ECS_SERVICE --query 'services[0].status' --output text 2>/dev/null | grep -q "ACTIVE"; then
          echo "Service exists, updating..."
          aws ecs update-service --cluster $ECS_CLUSTER --service $ECS_SERVICE --task-definition $ECS_TASK_DEFINITION
        else
          echo "Service doesn't exist, creating..."
          # Get default VPC and subnets
          VPC_ID=$(aws ec2 describe-vpcs --filters "Name=isDefault,Values=true" --query 'Vpcs[0].VpcId' --output text)
          SUBNET_IDS=$(aws ec2 describe-subnets --filters "Name=vpc-id,Values=$VPC_ID" --query 'Subnets[].SubnetId' --output text | tr '\t' ',')
          
          # Create security group for ECS service
          SECURITY_GROUP_ID=$(aws ec2 create-security-group \
            --group-name addtocloud-api-sg \
            --description "Security group for AddToCloud API" \
            --vpc-id $VPC_ID \
            --query 'GroupId' --output text 2>/dev/null || \
            aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=addtocloud-api-sg" \
            --query 'SecurityGroups[0].GroupId' --output text)
          
          # Add ingress rule for port 8080
          aws ec2 authorize-security-group-ingress \
            --group-id $SECURITY_GROUP_ID \
            --protocol tcp \
            --port 8080 \
            --cidr 0.0.0.0/0 2>/dev/null || true
          
          # Create service
          aws ecs create-service \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --task-definition $ECS_TASK_DEFINITION \
            --desired-count 1 \
            --launch-type FARGATE \
            --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_IDS],securityGroups=[$SECURITY_GROUP_ID],assignPublicIp=ENABLED}"
        fi

    - name: Wait for service to be stable
      run: |
        echo "Waiting for service to stabilize..."
        aws ecs wait services-stable --cluster $ECS_CLUSTER --services $ECS_SERVICE

    - name: Get service endpoint
      run: |
        # Get task ARN
        TASK_ARN=$(aws ecs list-tasks --cluster $ECS_CLUSTER --service-name $ECS_SERVICE --query 'taskArns[0]' --output text)
        
        if [ "$TASK_ARN" != "None" ] && [ "$TASK_ARN" != "" ]; then
          # Get public IP
          ENI_ID=$(aws ecs describe-tasks --cluster $ECS_CLUSTER --tasks $TASK_ARN --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' --output text)
          PUBLIC_IP=$(aws ec2 describe-network-interfaces --network-interface-ids $ENI_ID --query 'NetworkInterfaces[0].Association.PublicIp' --output text)
          
          echo "üöÄ Backend API deployed successfully!"
          echo "üìç API Endpoint: http://$PUBLIC_IP:8080"
          echo "üîç Health Check: http://$PUBLIC_IP:8080/health"
          echo "üìã Services API: http://$PUBLIC_IP:8080/api/v1/cloud/services"
          
          # Save endpoint for frontend configuration
          echo "API_ENDPOINT=http://$PUBLIC_IP:8080" >> $GITHUB_ENV
        else
          echo "‚ùå Failed to get task information"
          exit 1
        fi
