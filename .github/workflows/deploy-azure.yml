name: Deploy to Azure AKS

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'dev'
        type: choice
        options:
        - dev
        - staging
        - prod
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean

env:
  AZURE_RESOURCE_GROUP: addtocloud-${{ github.event.inputs.environment }}
  AKS_CLUSTER_NAME: addtocloud-${{ github.event.inputs.environment }}

jobs:
  deploy-azure:
    name: Deploy to Azure AKS
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Azure Login
        uses: azure/login@v1
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}
      
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'latest'
      
      - name: Setup Helm
        uses: azure/setup-helm@v3
        with:
          version: 'latest'
      
      - name: Get AKS credentials
        run: |
          az aks get-credentials --resource-group ${{ env.AZURE_RESOURCE_GROUP }} --name ${{ env.AKS_CLUSTER_NAME }} --overwrite-existing
      
      - name: Check cluster connectivity
        run: |
          kubectl cluster-info
          kubectl get nodes
      
      - name: Create namespace if not exists
        run: |
          kubectl create namespace addtocloud --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy secrets
        run: |
          kubectl create secret generic addtocloud-secrets \
            --from-literal=database-password="${{ secrets.DATABASE_PASSWORD }}" \
            --from-literal=jwt-secret="${{ secrets.JWT_SECRET }}" \
            --from-literal=api-key="${{ secrets.API_KEY }}" \
            --namespace=addtocloud \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy configmap
        run: |
          kubectl create configmap addtocloud-config \
            --from-literal=database-name="addtocloud" \
            --from-literal=database-host="postgres-service" \
            --from-literal=redis-host="redis-service" \
            --from-literal=mongodb-host="mongodb-service" \
            --from-literal=environment="${{ github.event.inputs.environment }}" \
            --namespace=addtocloud \
            --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Deploy applications
        run: |
          kubectl apply -k infrastructure/kubernetes/environments/${{ github.event.inputs.environment }}
      
      - name: Wait for deployment
        run: |
          kubectl wait --for=condition=available --timeout=600s deployment/addtocloud-frontend -n addtocloud
          kubectl wait --for=condition=available --timeout=600s deployment/addtocloud-backend -n addtocloud
      
      - name: Check deployment status
        run: |
          kubectl get pods -n addtocloud
          kubectl get services -n addtocloud
          kubectl get ingress -n addtocloud
      
      - name: Configure Azure DNS (if production)
        if: github.event.inputs.environment == 'prod'
        run: |
          # Get ingress IP
          INGRESS_IP=$(kubectl get service addtocloud-ingress-controller -n addtocloud -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          if [ -n "$INGRESS_IP" ]; then
            echo "Configuring DNS for IP: $INGRESS_IP"
            # Configure Azure DNS zone
            az network dns record-set a add-record \
              --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
              --zone-name addtocloud.tech \
              --record-set-name @ \
              --ipv4-address $INGRESS_IP
          fi
      
      - name: Run health check
        run: |
          # Wait for ingress to be ready
          sleep 60
          
          # Get ingress IP
          INGRESS_IP=$(kubectl get service addtocloud-ingress-controller -n addtocloud -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          
          if [ -n "$INGRESS_IP" ]; then
            echo "Testing health endpoint: http://$INGRESS_IP/api/health"
            curl -f http://$INGRESS_IP/api/health || echo "Health check failed"
          else
            echo "Ingress IP not yet available"
          fi
      
      - name: Deploy monitoring (optional)
        if: github.event.inputs.environment == 'prod'
        run: |
          kubectl apply -k infrastructure/kubernetes/monitoring
          kubectl wait --for=condition=available --timeout=300s deployment/prometheus -n monitoring
          kubectl wait --for=condition=available --timeout=300s deployment/grafana -n monitoring
      
      - name: Configure Azure Monitor integration
        if: github.event.inputs.environment == 'prod'
        run: |
          # Enable Azure Monitor for containers
          az aks enable-addons \
            --resource-group ${{ env.AZURE_RESOURCE_GROUP }} \
            --name ${{ env.AKS_CLUSTER_NAME }} \
            --addons monitoring
      
      - name: Post deployment notification
        if: always()
        run: |
          if [ "${{ job.status }}" == "success" ]; then
            echo "✅ Deployment to Azure AKS (${{ github.event.inputs.environment }}) completed successfully"
          else
            echo "❌ Deployment to Azure AKS (${{ github.event.inputs.environment }}) failed"
          fi
