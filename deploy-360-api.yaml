apiVersion: apps/v1
kind: Deployment
metadata:
  name: addtocloud-360-api
  labels:
    app: addtocloud-360-api
    version: v2.0
spec:
  replicas: 2
  selector:
    matchLabels:
      app: addtocloud-360-api
  template:
    metadata:
      labels:
        app: addtocloud-360-api
    spec:
      containers:
      - name: go-api
        image: golang:1.21-alpine
        ports:
        - containerPort: 8080
        env:
        - name: PORT
          value: "8080"
        command: ["/bin/sh"]
        args:
        - -c
        - |
          cd /app
          cat > main.go << 'EOF'
          package main

          import (
            "encoding/json"
            "fmt"
            "log"
            "net/http"
            "time"
          )

          type HealthResponse struct {
            Status            string `json:"status"`
            Message           string `json:"message"`
            FrontendConnected bool   `json:"frontend_connected"`
            Database          string `json:"database"`
            Services          int    `json:"services_count"`
            Timestamp         string `json:"timestamp"`
          }

          type ContactRequest struct {
            Name    string `json:"name"`
            Email   string `json:"email"`
            Message string `json:"message"`
          }

          type ContactResponse struct {
            Success   bool   `json:"success"`
            Message   string `json:"message"`
            RequestID string `json:"request_id"`
            Timestamp string `json:"timestamp"`
          }

          type AccessRequest struct {
            Service      string `json:"service"`
            Plan         string `json:"plan"`
            Company      string `json:"company"`
            Email        string `json:"email"`
            Requirements string `json:"requirements"`
          }

          type AccessResponse struct {
            Success   bool   `json:"success"`
            Message   string `json:"message"`
            Status    string `json:"status"`
            RequestID string `json:"request_id"`
            Timestamp string `json:"timestamp"`
          }

          type DeployRequest struct {
            Service struct {
              Name        string `json:"name"`
              Provider    string `json:"provider"`
              Category    string `json:"category"`
              Description string `json:"description"`
            } `json:"service"`
            Config struct {
              Name         string `json:"name"`
              Region       string `json:"region"`
              InstanceType string `json:"instanceType"`
              Environment  string `json:"environment"`
            } `json:"config"`
          }

          type DeployResponse struct {
            Success      bool   `json:"success"`
            Message      string `json:"message"`
            DeploymentID string `json:"deploymentId"`
            Status       string `json:"status"`
            EstimatedTime string `json:"estimatedTime"`
            Timestamp    string `json:"timestamp"`
          }

          func enableCORS(w http.ResponseWriter) {
            w.Header().Set("Access-Control-Allow-Origin", "*")
            w.Header().Set("Access-Control-Allow-Methods", "GET, POST, OPTIONS, PUT, DELETE")
            w.Header().Set("Access-Control-Allow-Headers", "Accept, Authorization, Cache-Control, Content-Type, DNT, If-Modified-Since, Keep-Alive, Origin, User-Agent, X-Requested-With")
          }

          func healthHandler(w http.ResponseWriter, r *http.Request) {
            enableCORS(w)

            if r.Method == "OPTIONS" {
              w.WriteHeader(http.StatusOK)
              return
            }

            response := HealthResponse{
              Status:            "healthy",
              Message:           "AddToCloud 360+ Services API Ready",
              FrontendConnected: true,
              Database:          "ready",
              Services:          360,
              Timestamp:         time.Now().UTC().Format(time.RFC3339),
            }

            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(response)
          }

          func contactHandler(w http.ResponseWriter, r *http.Request) {
            enableCORS(w)

            if r.Method == "OPTIONS" {
              w.WriteHeader(http.StatusOK)
              return
            }

            if r.Method != "POST" {
              w.WriteHeader(http.StatusMethodNotAllowed)
              json.NewEncoder(w).Encode(map[string]string{"error": "Method not allowed"})
              return
            }

            var contact ContactRequest
            if err := json.NewDecoder(r.Body).Decode(&contact); err != nil {
              w.WriteHeader(http.StatusBadRequest)
              json.NewEncoder(w).Encode(map[string]string{"error": "Invalid JSON"})
              return
            }

            response := ContactResponse{
              Success:   true,
              Message:   "Contact request received successfully",
              RequestID: fmt.Sprintf("contact_%d", time.Now().Unix()),
              Timestamp: time.Now().UTC().Format(time.RFC3339),
            }

            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(response)
          }

          func accessRequestHandler(w http.ResponseWriter, r *http.Request) {
            enableCORS(w)

            if r.Method == "OPTIONS" {
              w.WriteHeader(http.StatusOK)
              return
            }

            if r.Method != "POST" {
              w.WriteHeader(http.StatusMethodNotAllowed)
              json.NewEncoder(w).Encode(map[string]string{"error": "Method not allowed"})
              return
            }

            var access AccessRequest
            if err := json.NewDecoder(r.Body).Decode(&access); err != nil {
              w.WriteHeader(http.StatusBadRequest)
              json.NewEncoder(w).Encode(map[string]string{"error": "Invalid JSON"})
              return
            }

            response := AccessResponse{
              Success:   true,
              Message:   "Access request submitted successfully",
              Status:    "pending_review",
              RequestID: fmt.Sprintf("access_%d", time.Now().Unix()),
              Timestamp: time.Now().UTC().Format(time.RFC3339),
            }

            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(response)
          }

          func deployHandler(w http.ResponseWriter, r *http.Request) {
            enableCORS(w)

            if r.Method == "OPTIONS" {
              w.WriteHeader(http.StatusOK)
              return
            }

            if r.Method != "POST" {
              w.WriteHeader(http.StatusMethodNotAllowed)
              json.NewEncoder(w).Encode(map[string]string{"error": "Method not allowed"})
              return
            }

            var deploy DeployRequest
            if err := json.NewDecoder(r.Body).Decode(&deploy); err != nil {
              w.WriteHeader(http.StatusBadRequest)
              json.NewEncoder(w).Encode(map[string]string{"error": "Invalid JSON"})
              return
            }

            // Simulate deployment processing
            deploymentID := fmt.Sprintf("deploy_%s_%d", deploy.Service.Provider, time.Now().Unix())
            
            response := DeployResponse{
              Success:       true,
              Message:       fmt.Sprintf("%s %s deployment initiated successfully", deploy.Service.Provider, deploy.Service.Name),
              DeploymentID:  deploymentID,
              Status:        "provisioning",
              EstimatedTime: "3-5 minutes",
              Timestamp:     time.Now().UTC().Format(time.RFC3339),
            }

            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(response)
          }

          func rootHandler(w http.ResponseWriter, r *http.Request) {
            enableCORS(w)

            if r.Method == "OPTIONS" {
              w.WriteHeader(http.StatusOK)
              return
            }

            response := map[string]interface{}{
              "status":    "operational",
              "message":   "AddToCloud 360+ Services API",
              "endpoints": []string{"/api/health", "/api/v1/contact", "/api/v1/access-request", "/api/v1/deploy"},
              "services":  360,
              "providers": []string{"AWS", "Azure", "GCP", "CloudFlare", "DigitalOcean", "Linode", "Vultr"},
              "timestamp": time.Now().UTC().Format(time.RFC3339),
            }

            w.Header().Set("Content-Type", "application/json")
            json.NewEncoder(w).Encode(response)
          }

          func main() {
            http.HandleFunc("/", rootHandler)
            http.HandleFunc("/api/health", healthHandler)
            http.HandleFunc("/api/v1/contact", contactHandler)
            http.HandleFunc("/api/v1/access-request", accessRequestHandler)
            http.HandleFunc("/api/v1/deploy", deployHandler)

            port := ":8080"
            log.Printf("ðŸš€ AddToCloud 360+ Services API starting on port %s", port)
            log.Printf("ðŸŒ API endpoints ready:")
            log.Printf("   GET  /api/health")
            log.Printf("   POST /api/v1/contact")
            log.Printf("   POST /api/v1/access-request")
            log.Printf("   POST /api/v1/deploy")
            log.Printf("ðŸ“Š 360+ Cloud Services Available")

            if err := http.ListenAndServe(port, nil); err != nil {
              log.Fatal("âŒ Failed to start server:", err)
            }
          }
          EOF
          
          go mod init addtocloud-360-api
          go run main.go
        workingDir: /app
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /api/health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /api/health
            port: 8080
          initialDelaySeconds: 5
          periodSeconds: 5
---
apiVersion: v1
kind: Service
metadata:
  name: addtocloud-360-api-service
  labels:
    app: addtocloud-360-api
spec:
  type: LoadBalancer
  ports:
  - port: 80
    targetPort: 8080
    protocol: TCP
    name: http
  selector:
    app: addtocloud-360-api
